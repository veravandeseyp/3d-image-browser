<!doctype html>
<html>
<head>
  <title>Socket.IO chat</title>
  <style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font: 13px Helvetica, Arial; }
  form { background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; }
  form input { border: 0; padding: 10px; width: 90%; margin-right: .5%; }
  form button { width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; }
  #messages { list-style-type: none; margin: 0; padding: 0; }
  #messages li { padding: 5px 10px; }
  #messages li:nth-child(odd) { background: #eee; }
</style>
</head>
<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script>
$(function () {
  var socket = io();
  $('form').submit(function(){
    socket.emit('chat message', $('#m').val());
    $('#m').val('');
    return false;
  });
  socket.on('chat message', function(msg){
    $('#messages').append($('<li>').text(msg));
  });
});
</script>
<body>
  <u1 id="square">
    <script src="/three.js"></script>
    <script src="/TypedArrayUtils.js"></script>
    <script src="/OrbitControls.js"></script>
    <script src="/FlyControls.js"></script>
    <script>
    //Mouse Part

    mouse = new THREE.Vector2();
    accel = new THREE.Vector2();
    //gyro config
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    var renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setClearColor(0x000000, 1);
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
      controls.handleResize();
    }

    var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);
    var cube;
    //Cube
    var sprite = [];
    positions = new Float32Array( 64 * 64 * 3 );
    var kdtree;
    var clock = new THREE.Clock();
    var maxDistance = Math.pow( 120, 2 );

    javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

    console.log("Reading Texture");
    var myTexture = new THREE.TextureLoader()

    var distanceFunction = function ( a, b ) {
      return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );
    };
    myTexture = myTexture.load('master.png', function(map) {
      map.repeat.set(1/64, 1/64);
      map.wrapS = map.wrapT = THREE.RepeatWrapping;

      for(var i = 0; i < 64; i++) {
        var x_offset = Math.random()*50-25;
        var y_offset = Math.random()*50-25;
        var z_offset = Math.random()*50-25;

        for(var j = 0; j < 64; j++) {
          if(i == 17 && j == 38) {
            //This stopped overloading images
            break;
          } else {

            var tempTex = map.clone();
            tempTex.uuid = map.uuid;
            tempTex.version = map.version;
            tempTex.needsUpdate = true;
            var height = Math.floor((8192/150));

            tempTex.wrapS = tempTex.wrapT = THREE.RepeatWrapping;


            tempTex.offset.x = 1/64*j;
            tempTex.offset.y = -1/(height+1)*(i+1);

            var material = new THREE.SpriteMaterial( {map: tempTex, color: 0xffffff, fog: true } );
            sprite[sprite.length-1] = new THREE.Sprite(material);
            sprite[sprite.length-1].scale.set(1,150/124,1);



            sprite[sprite.length-1].position.z = Math.random()*10-5 + z_offset;


            positions[(sprite.length-1)*3] = sprite[sprite.length-1].position.x = Math.random()*10-5 + x_offset;
            positions[(sprite.length-1)*3+1] = sprite[sprite.length-1].position.y = Math.random()*10-5 + y_offset;
            positions[(sprite.length-1)*3+2] = sprite[sprite.length-1].position.z = Math.random()*10-5 + z_offset;

            scene.add( sprite[sprite.length-1] );

          }

        }
      }


    });

    console.log("Building tree");
    var measureStart = new Date().getTime();
    kdtree = new THREE.TypedArrayUtils.Kdtree( positions, distanceFunction, 3 );
    console.log( 'TIME building kdtree', new Date().getTime() - measureStart );



    camera.position.z = 5;
    var socket = io();

    //This is twisting motion

    // socket.on('accelX', function(msg){
    //   cube.rotation.x = msg/180*Math.PI,
    //   camera.rotation.x = msg/180*Math.PI

    // });

    //this is left to right

    socket.on('accelY', function(msg){
      //cube.rotation.y = msg/180*Math.PI,
      //camera.rotateY(-msg/180*Math.PI/10),
      camera.rotation.y -= msg/180*Math.PI/10,
      camera.rotation.z = 0

    });


    //This is the tilting forwards motion
    var direction;
    socket.on('accelZ', function(msg) {

    });

    socket.on('height', function(msg){
      //cube.rotation.z = msg/180*Math.PI*1.5,
      //camera.position.z += msg/180,
      direction = camera.getWorldDirection(),
      camera.position.add( direction.multiplyScalar(-msg*5) ),
      camera.rotation.z = 0;
    });

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    mouse.x = 0;
    mouse.y = 0;



    function render() {

      // update the picking ray with the camera and mouse position
      raycaster.setFromCamera( mouse, camera );
      // calculate objects intersecting the picking ray
      // var intersects = raycaster.intersectObjects( scene.children );
      //
      // scene.children.forEach(function(item) {
      //   item.material.color.set( 0xffffff );
      //   item.scale.x = 1;
      //   item.scale.y = 1;
      //
      // });
      //
      // for ( var i = 0; i < intersects.length; i++ ) {
      //   intersects[ i ].object.material.color.set( 0xff0000 );
      //   intersects[ i ].object.scale.x = 2;
      //   intersects[ i ].object.scale.y = 2;
      //
      // }
      renderer.render( scene, camera );
    }

    //Animation loop of cube
    function animate() {
      displayNearest( camera.position );

      requestAnimationFrame( animate );
      render();

    }
    animate();

    function displayNearest( position ) {
var imagePositionsInRange = kdtree.nearest( [ 0, 0, 0 ], 100, maxDistance );
      //var imagePositionsInRange = kdtree.nearest( [ position.x, position.y, position.z ], 100, maxDistance );
      var _frustum = new THREE.Frustum();
      var _projScreenMatrix = new THREE.Matrix4();
      _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );
      for ( var i = 0, il = imagePositionsInRange.length; i < il; i ++ ) {
        var object = imagePositionsInRange[ i ];
        //object.material.color.set(0xff0000);
        /*
        var objectPoint = new THREE.Vector3().fromArray( object[ 0 ].obj );
        if ( _frustum.containsPoint( objectPoint ) ) {
          var objectIndex = object[ 0 ].pos;
          // set the alpha according to distance
          alphas[ objectIndex ] = 1.0 / maxDistance * object[ 1 ];
          // update the attribute
          _particleGeom.attributes.alpha.needsUpdate = true;
        }*/
      }
    }

  </script>
  </u1>
  <ul id="messages"></ul>
  <form action="">
    <input id="m" autocomplete="off" /><button>Send</button>
  </form>
</body>
</html>
