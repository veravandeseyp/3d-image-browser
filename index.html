<!doctype html>
<html>
<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script>

// $(function () {
//   var socket = io();
//   $('form').submit(function(){
//     socket.emit('chat message', $('#m').val());
//     $('#m').val('');
//     return false;
//   });
//   socket.on('chat message', function(msg){
//     $('#messages').append($('<li>').text(msg));
//   });
// });
</script>
<body>
  <u1 id="square">
    <script src="/three.js"></script>
    <script src="/TypedArrayUtils.js"></script>
    <script src="/OrbitControls.js"></script>
    <script src="FirstPersonControls.js"></script>
    <script>
    var json
    var loader = new THREE.FileLoader();


    // $.getJSON("info.json", function(json_data) {
    //         json = json_data;
    //         console.log(json);
    //     });
    //Mouse Part
    document.body.addEventListener("keydown", function() {
      THREEx.FullScreen.request();
    }, false);
    var socket = io();
    mouse = new THREE.Vector2();
    accel = new THREE.Vector2();
    var controls;

    //gyro config
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    controls = new THREE.FirstPersonControls( camera );

    controls.movementSpeed = 100;
    controls.lookSpeed = 0.1;

    var renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setClearColor(0x000000, 1);
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
      controls.handleResize();
    }

    var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);
    var cube;
    //Cube
    var sprite = [];
    positions = new Float32Array( 32 * 32 * 3 );
    var kdtree;
    var clock = new THREE.Clock();
    var maxDistance = Math.pow( 120, 2 );

    javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

    console.log("Reading Texture");
    var myTexture = new THREE.TextureLoader()

    var distanceFunction = function ( a, b ) {
      return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );
    };


    loader.load(
      // resource URL
      'info.json',

      // Function when resource is loaded
      function ( data ) {
        // output the text to the console
        //console.log( JSON.parse(data) );
        json = JSON.parse(data);
        console.log(json);
        myTexture = myTexture.load('master.png', function(map) {
          map.repeat.set(1/json.setup.ximages, 1/(8192/json.setup.im_height));
          // map.repeat.set(1/32, 1/(8192/170));
          map.wrapS = map.wrapT = THREE.RepeatWrapping;
          for(var i = 0; i < json.setup.yimages; i++) {
            var x_offset = Math.random()*25-12;
            var y_offset = Math.random()*25-12;
            var z_offset = Math.random()*25-12;

            for(var j = 0; j < json.setup.ximages; j++) {
              if(i == json.setup.yimages && j == json.setup.ypartial) {
                //This stopped overloading images
                break;
              } else {

                var tempTex = map.clone();
                tempTex.uuid = map.uuid;
                tempTex.version = map.version;
                tempTex.needsUpdate = true;
                var height = ((8192/json.setup.im_height));

                tempTex.wrapS = tempTex.wrapT = THREE.RepeatWrapping;
                tempTex.offset.x = 1/json.setup.ximages*j;
                tempTex.offset.y = -1/(height)*(i+1);
                // tempTex.offset.x = 1/32;//*j;
                // tempTex.offset.y = -1/(height+1)*(i+1);
                var material = new THREE.SpriteMaterial( {map: tempTex, color: 0xffffff, fog: true } );
                sprite[sprite.length-1] = new THREE.Sprite(material);
                sprite[sprite.length-1].scale.set(1,json.setup.im_height/json.setup.im_width,1);

                sprite[sprite.length-1].position.z = Math.random()*10-5 + z_offset;


                positions[(sprite.length-1)*3] = sprite[sprite.length-1].position.x = Math.random()*5-3 + x_offset;
                positions[(sprite.length-1)*3+1] = sprite[sprite.length-1].position.y = Math.random()*5-3 + y_offset;
                positions[(sprite.length-1)*3+2] = sprite[sprite.length-1].position.z = Math.random()*5-3 + z_offset;

                scene.add( sprite[sprite.length-1] );

              }

            }

          }

        });
      },
    );



    console.log("Building tree");
    var measureStart = new Date().getTime();
    kdtree = new THREE.TypedArrayUtils.Kdtree( positions, distanceFunction, 3 );
    console.log( 'TIME building kdtree', new Date().getTime() - measureStart );



    camera.position.z = 5;

    //
    // //This is twisting motion
    //
    // // socket.on('accelX', function(msg){
    // //   cube.rotation.x = msg/180*Math.PI,
    // //   camera.rotation.x = msg/180*Math.PI
    //
    // // });
    //
    // //this is left to right
    //
    // socket.on('accelY', function(msg){
    //   //cube.rotation.y = msg/180*Math.PI,
    //   //camera.rotateY(-msg/180*Math.PI/10),
    //   camera.rotation.y -= msg/180*Math.PI/10,
    //   camera.rotation.z = 0
    //
    // });
    //
    //
    // //This is the tilting forwards motion
    // var direction;
    // socket.on('accelZ', function(msg) {
    //
    // });
    //
    // socket.on('height', function(msg){
    //   //cube.rotation.z = msg/180*Math.PI*1.5,
    //   //camera.position.z += msg/180,
    //   direction = camera.getWorldDirection(),
    //   camera.position.add( direction.multiplyScalar(-msg*5) ),
    //   camera.rotation.z = 0;
    // });

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    mouse.x = 0;
    mouse.y = 0;



    function render() {

      // update the picking ray with the camera and mouse position
      raycaster.setFromCamera( mouse, camera );
      //calculate objects intersecting the picking ray
      var intersects = raycaster.intersectObjects( scene.children );

      scene.children.forEach(function(item) {
        //item.material.color.set( 0xffffff );
        item.scale.x = 1;
        item.scale.y = 1;

      });
      var height = ((8192/json.setup.im_height));
      for ( var i = 0; i < intersects.length; i++ ) {
        //intersects[ i ].object.material.color.set( 0xff0000 );
        intersects[ i ].object.scale.x = 2;
        intersects[ i ].object.scale.y = 2;
        //console.log(intersects[ i ].object)
        var offsetx = intersects[ i ].object.material.map.offset.x;
        var offsety = intersects[ i ].object.material.map.offset.y;

        offsetx = offsetx * json.setup.ximages;
        offsety = (offsety * (height) + 1)*-1;

        console.log(offsety)


      }
      renderer.render( scene, camera );
    }

    //Animation loop of cube
    function animate() {
      displayNearest( camera.position );

      requestAnimationFrame( animate );
      render();
      controls.update( clock.getDelta() );
      renderer.render( scene, camera );
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
      controls.handleResize();
    }
    animate();

    function displayNearest( position ) {
      var imagePositionsInRange = kdtree.nearest( [ 0, 0, 0 ], 100, maxDistance );
      //var imagePositionsInRange = kdtree.nearest( [ position.x, position.y, position.z ], 100, maxDistance );
      var _frustum = new THREE.Frustum();
      var _projScreenMatrix = new THREE.Matrix4();
      _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );
      for ( var i = 0, il = imagePositionsInRange.length; i < il; i ++ ) {
        var object = imagePositionsInRange[ i ];
        //object.material.color.set(0xff0000);
        /*
        var objectPoint = new THREE.Vector3().fromArray( object[ 0 ].obj );
        if ( _frustum.containsPoint( objectPoint ) ) {
        var objectIndex = object[ 0 ].pos;
        // set the alpha according to distance
        alphas[ objectIndex ] = 1.0 / maxDistance * object[ 1 ];
        // update the attribute
        _particleGeom.attributes.alpha.needsUpdate = true;
      }*/
    }
  }

  </script>
</u1>
</body>
</html>
