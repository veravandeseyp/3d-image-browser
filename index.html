<!doctype html>
<html>
<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script>

// $(function () {
//   var socket = io();
//   $('form').submit(function(){
//     socket.emit('chat message', $('#m').val());
//     $('#m').val('');
//     return false;
//   });
//   socket.on('chat message', function(msg){
//     $('#messages').append($('<li>').text(msg));
//   });
// });
</script>
<body>
  <u1 id="square">
    <script src="/three.js"></script>
    <script src="/TypedArrayUtils.js"></script>
    <script src="/OrbitControls.js"></script>
    <script src="FirstPersonControls.js"></script>
    <script>


    //Distance Functions:
    var distance_function2 = function (a, b) {
      return Math.pow(a.position.x - b.position.x , 2) + Math.pow(a.position.y - b.position.y , 2) + Math.pow(a.position.z - b.position.z , 2);
    }

    var hypot_distance = function (a, b) {
      return Math.pow(a.position.x - b.position.x, 2) + Math.pow(a.position.y - b.position.y, 2);
    }

    //Listeners
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
      controls.handleResize();
    }

    ///THree Init
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    var renderer = new THREE.WebGLRenderer({antialias:true});

    camera.updateProjectionMatrix();
    scene.add(ambientLight);

    window.addEventListener( 'resize', onWindowResize, false );
    renderer.setClearColor(0x000000, 1);
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

        //FPS Counter:
    javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

    //Comms init
    var socket = io();

    //Controls Init
    var clock = new THREE.Clock();
    mouse = new THREE.Vector2();
    accel = new THREE.Vector2();
    var controls;
    controls = new THREE.FirstPersonControls( camera );
    controls.movementSpeed = 100;
    controls.lookSpeed = 0.1;

    console.log("Reading Texture");
    var myTexture = new THREE.TextureLoader()

    //Page Setup:
    var sprite = [];
    var json;
    var loader = new THREE.FileLoader();

    loader.load(
      // resource URL
      'info.json',
      // Function when resource is loaded
      function ( data ) {
        var full_counter = 0;
        // output the text to the console
        json = JSON.parse(data);
        var results = {};
        var genre_names = []
        results.genres = genre_names;
        results.genres.push({genre: json.images[0].genre});

        //Calculates number of unique genres
        json.images.forEach(function(x) {
          v = {genre: x.genre}
          if(v.genre != results.genres[results.genres.length -1].genre) {
            genre_names.push(v);
            results.genres = genre_names;
          } else {
          }
        });

        //Calculate Genre Spheres
        var cluster_diameter = 25;
        var image_distance = 10;

        // results.genres.forEach(function(x) {
        //   center = new THREE.Vector3(0,0,0);
        //   x.protosphere = new THREE.Sphere(center, cluster_diameter*2);
        // });
        //
        //
        // //console.log(json.images);
        // //Spaces the spheres
        // results.genres.forEach(function(x) {
        //   results.genres.forEach(function(y) {
        //     if(x.genre != y.genre) {
        //       while(x.protosphere.containsPoint(y.protosphere.center)) {
        //         y.protosphere.center.x++;
        //
        //       }
        //     }
        //   });
        // });
        //
        // json.images.forEach(function(x) {
        //   results.genres.forEach(function(y) {
        //     if(y.genre == x.genre) {
        //       json.images[json.images.indexOf(x)].genre_number = results.genres.indexOf(y);
        //       json.images[json.images.indexOf(x)].sphere = y.protosphere;
        //     }
        //   });
        // })
        //
        // //Add Spike enumerations
        // var enum_count;
        // var genre_count;
        //
        // //THIS IS Not working!
        // for(var i = 0; i < json.images.length; i++) {
        //   if(i == 0) {
        //     genre_count = 0;
        //     enum_count = 0;
        //     json.images[i].spike = enum_count;
        //     joint_name = json.images[i].fname + json.images[i].lname;
        //     json.images[i].jname = joint_name;
        //     //Genre Changed
        //   } else if(json.images[i].genre != json.images[i-1].genre) {
        //     enum_count = 0;
        //     genre_count++;
        //   }
        //
        //   if(i != 0) {
        //     joint_name = json.images[i].fname + json.images[i].lname;
        //     json.images[i].jname = joint_name;
        //     l_joint_name = json.images[i-1].fname + json.images[i-1].lname;
        //     if(joint_name != l_joint_name) {
        //       enum_count++;
        //       json.images[i].spike = enum_count;
        //     }
        //   }
        // }
        // console.log(json.images);
        //
        // //Star mechanism
        // var last_spike = 0;
        // var image_sep = 5;
        // for(var i = 0; i < json.images.length; i++) {
        //   var max_spikes = 0;
        //   var j = i;
        //   while(max_spikes < json.images[j].spike) {
        //     max_spikes = json.images[j].spike;
        //     j++;
        //   }
        //   var angle = 360/(max_spikes+1);
        //   angle = json.images[i].spike*angle;
        //
        //   json.images[i].star_offsetx = image_sep*Math.sin(angle)*last_spike;
        //   json.images[i].star_offsety = image_sep*Math.cos(angle)*last_spike;
        //
        //   if(last_spike == max_spikes) {
        //     last_spike = 0;
        //   } else {
        //     last_spike++;
        //   }
        // }

        //console.log(json);
        myTexture = myTexture.load('master.png', function(map) {
          map.repeat.set(1/json.setup.ximages, 1/(8192/json.setup.im_height));
          // map.repeat.set(1/32, 1/(8192/170));
          map.wrapS = map.wrapT = THREE.RepeatWrapping;
          positions = new Float32Array(json.setup.yimages*json.setup.ximages*3)
          for(var i = 0; i < json.setup.yimages; i++) {
            var x_offset = Math.random()*25-12;
            var y_offset = Math.random()*25-12;
            var z_offset = Math.random()*25-12;
            for(var j = 0; j < json.setup.ximages; j++) {
              if(i == json.setup.yimages-1 && j == json.setup.ypartial) {
                //This stopped overloading images
                break;
              } else {

                var tempTex = map.clone();
                tempTex.uuid = map.uuid;
                tempTex.version = map.version;
                tempTex.needsUpdate = true;
                var height = ((8192/json.setup.im_height));

                tempTex.wrapS = tempTex.wrapT = THREE.RepeatWrapping;
                tempTex.offset.x = 1/json.setup.ximages*j;
                tempTex.offset.y = -1/(height)*(i+1);

                var material = new THREE.SpriteMaterial( {map: tempTex, color: 0xffffff, fog: true } );

                sprite.push(new THREE.Sprite(material));
                //console.log(sprite.length-1)
                sprite[sprite.length-1].scale.set(1,json.setup.im_height/json.setup.im_width,1);

                var sphere_belonging;
                for(var k = 0; k < json.images.length; k++) {
                  //console.log(json.images[j]);
                  if(json.images[k].yloc == i && json.images[k].xloc == j) {

                    // json.images[k].genre
                    // sphere_belonging = results.images[]
                    sprite[sprite.length-1].name = json.images[k].filename;
                    //console.log(sprite[sprite.length-1].name);
                    // sprite[sprite.length-1].position.x = json.images[k].sphere.center.x + json.images[k].start_offsetx;
                    // sprite[sprite.length-1].position.y = json.images[k].sphere.center.y + json.images[k].start_offsety;
                    // sprite[sprite.length-1].position.z = json.images[k].sphere.center.z + 0;

                    break;

                  }
                }

                sprite[sprite.length-1].position.x = Math.random()*5-3 + x_offset;
                sprite[sprite.length-1].position.y = Math.random()*5-3 + y_offset;
                sprite[sprite.length-1].position.z = Math.random()*5-3 + z_offset;
                full_counter += 1;
                scene.add( sprite[sprite.length-1] );

              }

            }

          }
        });
      },
    );



    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    mouse.x = 0; //Set for middle of screen
    mouse.y = 0;  //Set for middle of screen


    function render() {
      var s_0 = sprite[0];
      var s_1 = sprite[0];
      sprite.forEach(function(s) {
        //find closest to camera
        if(distance_function2(s, camera) <= distance_function2(s_0, camera)) s_0 = s;
        //Find closest to camera centre objects
        if(hypot_distance(camera, s) <= hypot_distance(camera, s_1)) s_1 = s;
      });

      // update the picking ray with the camera and mouse position
      raycaster.setFromCamera( mouse, camera );
      //calculate objects intersecting the picking ray
      var intersects = raycaster.intersectObjects( scene.children );

      scene.children.forEach(function(item) {
        item.scale.x = 1;
        item.scale.y = 1;

      });
      var height = ((8192/json.setup.im_height));
      var s_2 = sprite[0];
      for ( var i = 0; i < intersects.length; i++ ) {
        //intersects[ i ].object.material.color.set( 0xff0000 );
        // intersects[ i ].object.scale.x = 2;
        // intersects[ i ].object.scale.y = 2;
        s_2 = intersects[ i ].object;
        // var offsetx = intersects[ i ].object.material.map.offset.x;
        // var offsety = intersects[ i ].object.material.map.offset.y;
        //
        // offsetx = offsetx * json.setup.ximages;
        // offsety = Math.abs((offsety * (height) + 1)*-1);
        //
        //Calc image pointed to:
        // for(var j = 0; j < json.images.length; j++) {
        //   //console.log(json.images[j]);
        //   if(json.images[j].yloc == offsety && json.images[j].xloc == offsetx) {
        //     //s_2 = json.images[j].filename;
        //     break;
        //   }
        // }
      }


      renderer.render( scene, camera );
    }


    //Animation loop of cube
    function animate() {
      requestAnimationFrame( animate );
      render();
      controls.update( clock.getDelta() );
    }
    animate();

    </script>
  </u1>
</body>
</html>
