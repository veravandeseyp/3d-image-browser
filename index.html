<!doctype html>
<html>
<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script>

// $(function () {
//   var socket = io();
//   $('form').submit(function(){
//     socket.emit('chat message', $('#m').val());
//     $('#m').val('');
//     return false;
//   });
//   socket.on('chat message', function(msg){
//     $('#messages').append($('<li>').text(msg));
//   });
// });
</script>
<body>
  <u1 id="square">
    <script src="/three.js"></script>
    <script src="/TypedArrayUtils.js"></script>
    <script src="/OrbitControls.js"></script>
    <script src="FirstPersonControls.js"></script>
    <script>
    var json;
    var loader = new THREE.FileLoader();


    // $.getJSON("info.json", function(json_data) {
    //         json = json_data;
    //         console.log(json);
    //     });
    //Mouse Part
    document.body.addEventListener("keydown", function() {
      THREEx.FullScreen.request();
    }, false);
    var socket = io();
    mouse = new THREE.Vector2();
    accel = new THREE.Vector2();
    var controls;

    //gyro config
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.updateProjectionMatrix();

    controls = new THREE.FirstPersonControls( camera );

    controls.movementSpeed = 100;
    controls.lookSpeed = 0.1;

    var renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setClearColor(0x000000, 1);
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );
      controls.handleResize();
    }

    var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);
    var cube;
    //Cube
    var sprite = [];
    var positions;// = new Float32Array(32*32*3);
    var kdtree;
    var clock = new THREE.Clock();
    var maxDistance = Math.pow( 10, 2 );
    window.addEventListener( 'resize', onWindowResize, false );
    javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//rawgit.com/mrdoob/stats.js/master/build/stats.min.js';document.head.appendChild(script);})()

    console.log("Reading Texture");
    var myTexture = new THREE.TextureLoader()

    var distanceFunction = function ( a, b ) {
      return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );
    };

    var distance_function2 = function (a, b) {
      return Math.pow(a.position.x - b.position.x , 2) + Math.pow(a.position.y - b.position.y , 2) + Math.pow(a.position.z - b.position.z , 2);
    }


    loader.load(
      // resource URL
      'info.json',

      // Function when resource is loaded
      function ( data ) {
        var full_counter = 0;
        // output the text to the console
        //console.log( JSON.parse(data) );
        json = JSON.parse(data);
        //console.log(json);
        myTexture = myTexture.load('master.png', function(map) {
          map.repeat.set(1/json.setup.ximages, 1/(8192/json.setup.im_height));
          // map.repeat.set(1/32, 1/(8192/170));
          map.wrapS = map.wrapT = THREE.RepeatWrapping;
          positions = new Float32Array(json.setup.yimages*json.setup.ximages*3)
          for(var i = 0; i < json.setup.yimages; i++) {
            var x_offset = Math.random()*25-12;
            var y_offset = Math.random()*25-12;
            var z_offset = Math.random()*25-12;

            for(var j = 0; j < json.setup.ximages; j++) {
              if(i == json.setup.yimages-1 && j == json.setup.ypartial) {
                //This stopped overloading images
                break;
              } else {

                var tempTex = map.clone();
                tempTex.uuid = map.uuid;
                tempTex.version = map.version;
                tempTex.needsUpdate = true;
                var height = ((8192/json.setup.im_height));

                tempTex.wrapS = tempTex.wrapT = THREE.RepeatWrapping;
                tempTex.offset.x = 1/json.setup.ximages*j;
                tempTex.offset.y = -1/(height)*(i+1);

                var material = new THREE.SpriteMaterial( {map: tempTex, color: 0xffffff, fog: true } );

                sprite.push(new THREE.Sprite(material));
                console.log(sprite.length-1)
                sprite[sprite.length-1].scale.set(1,json.setup.im_height/json.setup.im_width,1);


                for(var k = 0; k < json.images.length; k++) {
                  //console.log(json.images[j]);
                  if(json.images[k].yloc == i && json.images[k].xloc == j) {
                    sprite[sprite.length-1].name = json.images[k].filename;
                    console.log(sprite[sprite.length-1].name);
                    break;

                  }
                }

                sprite[sprite.length-1].position.x = Math.random()*5-3 + x_offset;
                sprite[sprite.length-1].position.y = Math.random()*5-3 + y_offset;
                sprite[sprite.length-1].position.z = Math.random()*5-3 + z_offset;


                // positions[full_counter*3+0] = sprite[sprite.length-1].position.x;
                // positions[full_counter*3+1] = sprite[sprite.length-1].position.y;
                // positions[full_counter*3+2] = sprite[sprite.length-1].position.z;

                //console.log(positions[full_counter]);
                full_counter += 1;
                scene.add( sprite[sprite.length-1] );

              }

            }

          }
          // console.log("Building tree");
          // var measureStart = new Date().getTime();
          // kdtree = new THREE.TypedArrayUtils.Kdtree( positions, distanceFunction, 3 );
          // console.log( 'TIME building kdtree', new Date().getTime() - measureStart );
        });
      },
    );



    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();
    mouse.x = 0;
    mouse.y = 0;


    var hypot_distance = function (a, b) {
      return Math.pow(a.position.x - b.position.x, 2) + Math.pow(a.position.y - b.position.y, 2);
    }

    function render() {
      //calc closest image
      var s_0 = sprite[0];
      sprite.forEach(function(s) {
        if(distance_function2(s, camera) <= distance_function2(s_0, camera))
          s_0 = s;
      });
      console.log(s_0.name);

      // update the picking ray with the camera and mouse position
      raycaster.setFromCamera( mouse, camera );
      //calculate objects intersecting the picking ray
      var intersects = raycaster.intersectObjects( scene.children );

      s_1 = sprite[0];
      //Find closest to camera centre objects
      sprite.forEach(function(s) {
        if(hypot_distance(camera, s) <= hypot_distance(camera, s_1))
          s_1 = s;
      });
      console.log(s_1.name)

      scene.children.forEach(function(item) {
        //item.material.color.set( 0xffffff );
        item.scale.x = 1;
        item.scale.y = 1;

      });
      var height = ((8192/json.setup.im_height));
      var s_2 = sprite[0];
      for ( var i = 0; i < intersects.length; i++ ) {
        //intersects[ i ].object.material.color.set( 0xff0000 );
        // intersects[ i ].object.scale.x = 2;
        // intersects[ i ].object.scale.y = 2;
        //console.log(intersects[ i ].object)
        s_2 = intersects[ i ].object;
        // var offsetx = intersects[ i ].object.material.map.offset.x;
        // var offsety = intersects[ i ].object.material.map.offset.y;
        //
        // offsetx = offsetx * json.setup.ximages;
        // offsety = Math.abs((offsety * (height) + 1)*-1);
        //
        //Calc image pointed to:
        for(var j = 0; j < json.images.length; j++) {
          //console.log(json.images[j]);
          if(json.images[j].yloc == offsety && json.images[j].xloc == offsetx) {
            //s_2 = json.images[j].filename;
            //console.log(json.images[j].filename);
            break;
          }
        }
      }


      renderer.render( scene, camera );
    }


    //Animation loop of cube
    function animate() {
      if(kdtree != null) {
        displayNearest( camera.position );
      }
      requestAnimationFrame( animate );
      render();
      controls.update( clock.getDelta() );
      //renderer.render( scene, camera );
    }



    //Find nearest object infront of player

    // function displayNearest( position ) {
    //   var closestObject;
    //   var imagePositionsInRange = kdtree.nearest( [ 0, 0, 0 ], 20, maxDistance );
    //   var imagePositionsInRange = kdtree.nearest( [ position.x, position.y, position.z ], 20, maxDistance );
    //   var _frustum = new THREE.Frustum();
    //   var _projScreenMatrix = new THREE.Matrix4();
    //   _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    //   _frustum.setFromMatrix( _projScreenMatrix );
    //   for ( var i = 0, il = imagePositionsInRange.length; i < il; i ++ ) {
    //     var object = imagePositionsInRange[ i ];
    //
    //     var objectPoint = new THREE.Vector3().fromArray( object[ 0 ].obj );
    //
    //     if ( _frustum.containsPoint( objectPoint ) ) {
    //       var objectIndex = Math.floor(object[ 0 ].pos/3.0);
    //
    //       console.log(objectIndex)
    //       // set the alpha according to distance
    //       // if(closestObject == null) {
    //       //   closestObject = sprite[objectIndex];
    //       // } else {// if(Math.abs(objectPoint.z-camera.position.z) < Math.abs(closestObject.position.z-camera.position.z)) {
    //       //   closestObject = sprite[objectIndex];
    //       //
    //       //   //Calc index and filename
    //       //   var height = ((8192/json.setup.im_height));
    //       //   var offsetx = closestObject.material.map.offset.x;
    //       //   var offsety = closestObject.material.map.offset.y;
    //       //
    //       //   offsetx = offsetx * json.setup.ximages;
    //       //   offsety = Math.abs((offsety * (height) + 1)*-1);
    //       //   //console.log(offsetx);
    //       //   //console.log(json.images[j]);
    //       //   for(var j = 0; j < json.images.length; j++) {
    //       //
    //       //     if(json.images[j].yloc == offsety && json.images[j].xloc == offsetx) {
    //       //       console.log(json.images[j].filename);
    //       //       break;
    //       //     }
    //       //   }
    //       // }
    //     }
    //     //alphas[ objectIndex ] = 1.0 / maxDistance * object[ 1 ];
    //     // update the attribute
    //     //_particleGeom.attributes.alpha.needsUpdate = true;
    //   }
    // }
    animate();

  </script>
</u1>
</body>
</html>
